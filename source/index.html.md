---
title: API Reference

toc_footers:
  - <a href='#'>Sign Up for a Developer Key</a>
  - <a href='https://github.com/slatedocs/slate'>Documentation Powered by Slate</a>

includes:
  - errors

search: true
---

# CoinFLEX Trade Engine APIs

CoinFLEX's application programming interfaces (APIs) provide our clients programmatic access to control aspects of their accounts and to place orders on CoinFLEX's trading platforms.

CoinFLEX provides several APIs:

* our native [WebSocket API][]
* a [RESTful API](REST.md)
* an [Event Stream resource](EventStream.md)
* a second futures [Event Stream resource](FUTURES.md#get-borrowerevents) for your collateral, leverage and margin

Using these interfaces it is possible to make both authenticated and unauthenticated API calls, with the exception of the Futures Event Stream which is authenticated only.

Access keys are available on the CoinFLEX logged-in dashboard page for verified users which, in conjunction with your account password, allow authenticated use these APIs.


## General notes

To protect the performance of the system, CoinFLEX imposes certain limits on the rates at which you may issue commands to the API. Please see [LIMITS.md](LIMITS.md).

All quantities and prices are transmitted and received as integers with implicit scale factors. For scale information, please see [SCALE.md](SCALE.md).

CoinFLEX has published [client libraries][] for several popular languages to aid you in implementing your client application.


## Getting started with the WebSocket API

**The [WebSocket API][] is accessible via [WebSocket][] connection to the following URLs:**


DEMO/STAGE site

`wss://stgapi.coinflex.com/v1   (encrypted)`

LIVE site

`wss://api.coinflex.com/v1      (encrypted)`

Commands, replies, and notifications traverse the WebSocket in text frames with [JSON][]-formatted payloads.

<aside class="success">
We strongly recommend that you use TLS transport for all connections.
</aside>

[Click here for more details on how to use the WebSocket API][WebSocket API]



[WebSocket API]: #WEBSOCKET-README.md
[JSON]: https://tools.ietf.org/html/rfc4627 (IETF RFC 4627)
[WebSocket]: https://tools.ietf.org/html/rfc6455 (IETF RFC 6455)
[client libraries]: https://github.com/coinflex-exchange/


# CoinFLEX Authentication Process

[WebSocket clients](#WEBSOCKET-README.md) authenticate by sending an authentication message containing a numeric user identifier, a cookie (described as an API key on the CoinFLEX website), a nonce chosen by the client, and an [ECDSA][] signature. The signature covers the user identifier, a nonce chosen by the server (which is transmitted to the client upon its connecting to the server), and the nonce chosen by the client. The connection is secured using TLS.

## Protocol

> **Example**

> Suppose a client whose user identifier is 1 and whose passphrase is "opensesame" wishes to authenticate to the WebSocket server.

> 1\. The client connects to the server and performs the WebSocket handshake.

> 2\. The server sends a `Welcome` notification and a randomly generated 16-bytes `server nonce`:

```json
{
    "notice": "Welcome",
    "nonce": "azRzAi5rm1ry/l0drnz1vw=="
}
```

> 3\. The client decodes the `server nonce` into these 16 bytes:

```yml
0x6b347302 2e6b9b5a f2fe5d1d ae7cf5bf
```

> N.B: Spaces are shown for the sake of clarity and do not denote elements of the actual value.

> 4\. The client randomly generates a 16-byte `client nonce`:

```yml
0xf08c98ca f1fd82e8 cea9825d bff04fd0
```

> 5\. The client encodes the `client nonce` using base64:

```yml
8IyYyvH9gujOqYJdv/BP0A==
```

> 6\. The client's `cookie` is:

```yml
HGREqcILTz8blHa/jsUTVTNBJlg=
```

> 7\. The client constructs a 40-byte `message` to sign, consisting of its `user_id`, the `server nonce`, and the `client nonce`:

```yml
0x00000000 00000001
0x6b347302 2e6b9b5a f2fe5d1d ae7cf5bf
0xf08c98ca f1fd82e8 cea9825d bff04fd0
```

> 8\. The client constructs a `seed` for its `private key`, consisting of its `user_id` and UTF-8-encoded passphrase:

```yml
0x00000000 00000001
0x6f70656e 73657361 6d65
```

> 9\. The client hashes its `seed` using SHA-224 to obtain its `private key`:

```yml
0xb89ea7fc d22cc059 c2673dc2 4ff40b97 83074646 86560d0a d7561b83
```

> 10\. The client [signs][ECDSA] the 28-byte SHA-224 digest of the 40-byte `message` using its `private key` under **secp224k1** and obtains, for example:

```yml
r = 0x3fb77a9d 7b5b2a68 209e76f6 872078c5 791340d5 989854ad a3ab735e
s = 0x34b84341 2f18a910 f18a7d4c e1d35978 60e6345b 22bf7894 cf67780a
```

> The [sign_secp224k1][] utility may be used to produce the `signature`.

> N.B: The `signature` (r, s) generated by the ECDSA is non-deterministic. Furthermore, the `signature` (r, s) is still non-deterministic if you use the deterministic `server nonce` and `client nonce` to build the codes, this is due to the nature of ECDSA.

> 11\. The client encodes the `signature` using base64:

```yml
P7d6nXtbKmggnnb2hyB4xXkTQNWYmFSto6tzXg==
NLhDQS8YqRDxin1M4dNZeGDmNFsiv3iUz2d4Cg==
```

> 12\. The client sends an `Authenticate` command to the server:

```json
{
    "method": "Authenticate",
    "user_id": 1,
    "cookie": "HGREqcILTz8blHa/jsUTVTNBJlg=",
    "nonce": "8IyYyvH9gujOqYJdv/BP0A==",
    "signature": [
        "P7d6nXtbKmggnnb2hyB4xXkTQNWYmFSto6tzXg==",
        "NLhDQS8YqRDxin1M4dNZeGDmNFsiv3iUz2d4Cg=="
    ]
}
```

> 13\. The server verifies the cookie and signature and returns a success response:

```json
{
    "error_code": 0
}
```

Authentication to the WebSocket server is by a `Welcome` notification sent to the client and an `Authenticate` command sent by the client.

* The `Welcome` notification contains a `nonce` field, whose value is a base64-encoded nonce that has been randomly generated by the server. The nonce is 16 bytes, and the base64 encoding transforms it into a 24-character string. This 16-byte nonce is hereafter referenced as the *server nonce*.
* The `Authenticate` command contains the following fields:
	* **`user_id`:** *(integer)* The unique numeric identifier of the authenticating user.
	* **`cookie`:** *(string)* A base64-encoded value that varies by user but is fixed for each specific user. In the CoinFLEX web interface, this authentication cookie is called an "API Key."
	* **`nonce`:** *(string)* A base64-encoded nonce that has been randomly generated by the client. The nonce is 16 bytes, and the base64 encoding transforms it into a 24-character string. This 16-byte nonce is hereafter referenced as the *client nonce*.
	* **`signature`:** *(pair of strings)* The base64-encoded *r* and *s* values of an [ECDSA][] signature over the SHA-224 digest of a message consisting of the concatenation of the 8-byte (big-endian) user identifier, the 16-byte server nonce, and the 16-byte client nonce. The signature uses the **secp224k1** curve parameters published by the [Standards for Efficient Cryptography Group][SECG] in [SEC 2: Recommended Elliptic Curve Domain Parameters version 2.0][SEC2] ([mirror][SEC2-mirror]). The private key used in signing is the 224-bit (big-endian) integer interpretation of the SHA-224 hash of the concatenation of the 8-byte (big-endian) user identifier and the UTF-8-encoded passphrase of the user.

[API]: https://github.com/coinflex-exchange/API/blob/master/WEBSOCKET-README.md
[ECDSA]: http://en.wikipedia.org/wiki/Elliptic_Curve_DSA
[SECG]: http://www.secg.org/
[SEC2]: http://www.secg.org/download/aid-784/sec2-v2.pdf
[SEC2-mirror]: http://www.shield-kratos.com/pdf/sec2-v2.pdf
[sign_secp224k1]: https://github.com/coinflex-exchange/libecp#sign_secp224k1


# CoinFLEX BIST API

BIST is no longer supported by CoinFLEX.


# Contracts

## Dates

Futures contracts will run for 2 months and end at midday (UTC) on the final Friday of the named month.
There will also be a ramp-up period that starts on Wednesday at midday (UTC) leading up to the final Friday of the
named month.

In the 24 hours starting from the Wednesday at 12pm (UTC) until 12pm (UTC) on Thursday, CoinFLEX will
increase the margin requirement for all users. In the final 24 hours leading to the final Friday of the month, this margin
requirement will be maintained.

| Month | 2020 (ramp-up start)| 2020 (expiry)     | code |
|:------|:--------------------|:------------------|:-----|
|  JAN  |    Wed, 29th Jan    |   Fri, 31st Jan   |  F   |
|  FEB  |    Wed, 26th Feb    |   Fri, 28th Feb   |  G   |
|  MAR  |    Wed, 25th Mar    |   Fri, 27th Mar   |  H   |
|  APR  |    Wed, 22nd Apr    |   Fri, 24th Apr   |  J   |
|  MAY  |    Wed, 27th May    |   Fri, 29th May   |  K   |
|  JUN  |    Wed, 24th Jul    |   Fri, 26th Jun   |  M   |
|  JUL  |    Wed, 29th Jul    |   Fri, 31st Jul   |  N   |
|  AUG  |    Wed, 26th Aug    |   Fri, 28th Aug   |  Q   |
|  SEP  |    Wed, 23rd Sep    |   Fri, 25th Sep   |  U   |
|  OCT  |    Wed, 28th Oct    |   Fri, 30th Oct   |  V   |
|  NOV  |    Wed, 25th Nov    |   Fri, 27th Nov   |  X   |
|  DEC  |    Wed, 23rd Dec    |   Fri, 25th Dec   |  Z   |


# Event Stream

DEMO/STAGE site

* `https://stgwebapi.coinflex.com/event-stream`
    * Version 1

LIVE site

* `https://webapi.coinflex.com/event-stream`
    * Version 1

CoinFLEX offers an Event Stream resource that complies with the [Server-Sent Events] specification by the W3C. This resource delivers a continuous, consistent stream of events related to market and account activity on the CoinFLEX platform. It is offered as a simpler alternative to CoinFLEX's [WebSocket API] for clients that do not require bidirectional communication with the platform.

The Event Stream resource supports the standard `Last-Event-ID` request header to enable transiently disconnected clients to reconnect and resume the event stream without missing any events. See the [Server-Sent Events] specification for details.

## Authentication

**[[ Version 2:** The Event Stream resource may be requested without authentication, in which case only public events (order book and ticker changes) are returned. **]]**

Requests for the Event Stream resource **[[ Version 1:** must **]] [[ Version 2:** may **]]** authenticate using [HTTP Basic Authentication], wherein the *user-id* is the concatenation of user's numeric ID, a slash, and the user's Base64-encoded API key, and the *password* is the user's password or the Base64 encoding of the user's 28-byte private key that is derived from the user's ID and password. Authenticated requests will receive account-private events (balance changes and more details on the user's own order events) in addition to the public events.

## BalanceChanged

> **[[ Version 1:**

```javascript
event: BalanceChanged
data: {
data:   "asset": <integer>,
data:   "balance": <integer>
data: }
```
> **]]**

> **[[ Version 2:**

```javascript
event: BalanceChanged
data: {
data:   "asset": <integer>,
data:   "available": <integer>,
data:   "reserved": <integer>
data: }
```
> **]]**

* **`asset`:** *(integer)* The numeric identifier of the asset whose available balance in the user's account changed.
* **[[ Version 1: `balance` ]] [[ Version 2: `available` ]]:** *(integer)* The [scaled] available amount of the specified asset in the user's account.
* **[[ Version 2: `reserved`:** *(integer)* The [scaled] reserved amount of the specified asset in the user's account. **]]**

## OrderOpened

```javascript
event: OrderOpened
data: {
data:   "base": <integer>,
data:   "counter": <integer>,
data:   "id": <integer>,
data:   "tonce": <integer>,
data:   "quantity": <integer>,
data:   "price": <integer>,
data:   "time": <integer>
data: }
```

* **`base`:** *(integer)* The numeric identifier of the base asset of the order.
* **`counter`:** *(integer)* The numeric identifier of the counter asset of the order.
* **`id`:** *(integer)* The numeric identifier of the order.
* **`tonce`:** *(integer or `null`, conditional)* The tonce given in the `PlaceOrder` command that opened the order, or `null` if that command did not specify a tonce. Present only if the authenticated user is the owner of the order.
* **`quantity`:** *(integer)* The [scaled] amount of the base asset that is to be traded. It is negative for a sell order and positive for a buy order.
* **`price`:** *(integer)* The [scaled] price at which the order offers to trade.
* **`time`:** *(integer)* The microsecond Unix timestamp at which the order was opened.

## OrdersMatched

```javascript
event: OrdersMatched
data: {
data:   "base": <integer>,
data:   "counter": <integer>,
data:   "bid": <integer>,
data:   "bid_tonce": <integer>,
data:   "ask": <integer>,
data:   "ask_tonce": <integer>,
data:   "quantity": <integer>,
data:   "price": <integer>,
data:   "total": <integer>,
data:   "bid_rem": <integer>,
data:   "ask_rem": <integer>,
data:   "time": <integer>,
data:   "bid_base_fee": <integer>,
data:   "bid_counter_fee": <integer>,
data:   "ask_base_fee": <integer>,
data:   "ask_counter_fee": <integer>
data: }
```

* **`base`:** *(integer)* The numeric identifier of the base asset of the orders.
* **`counter`:** *(integer)* The numeric identifier of the counter asset of the orders.
* **`bid`:** *(integer, conditional)* The numeric identifier of the bid order that matched. Omitted if the bid was a market order.
* **`bid_tonce`:** *(integer, conditional)* The tonce given in the `PlaceOrder` command that opened the bid order, or `null` if that command did not specify a tonce. Present only if the authenticated user is the owner of the bid order.
* **`ask`:** *(integer, conditional)* The numeric identifier of the ask order that matched. Omitted if the ask was a market order.
* **`ask_tonce`:** *(integer, conditional)* The tonce given in the `PlaceOrder` command that opened the ask order, or `null` if that command did not specify a tonce. Present only if the authenticated user is the owner of the ask order.
* **`quantity`:** *(integer)* The [scaled] amount of the base asset that was traded.
* **`price`:** *(integer)* The [scaled] price at which the trade executed.
* **`total`:** *(integer)* The [scaled] amount of the counter asset that was traded.
* **`bid_rem`:** *(integer, conditional)* The [scaled] quantity remaining in the bid order after the trade. It is always positive. Omitted if the bid was a market order.
* **`ask_rem`:** *(integer, conditional)* The [scaled] quantity remaining in the ask order after the trade. It is always positive. Omitted if the ask was a market order.
* **`time`:** *(integer)* The microsecond Unix timestamp at which the trade executed.
* **`bid_base_fee`:** *(integer)* The [scaled] amount of the base asset that was charged to the buyer as a trade fee.
* **`bid_counter_fee`:** *(integer)* The [scaled] amount of the counter asset that was charged to the buyer as a trade fee.
    * `bid_base_fee` and `bid_counter_fee` are present only if the authenticated user is the owner of the bid order.
* **`ask_base_fee`:** *(integer)* The [scaled] amount of the base asset that was charged to the seller as a trade fee.
* **`ask_counter_fee`:** *(integer)* The [scaled] amount of the counter asset that was charged to the seller as a trade fee.
    * `ask_base_fee` and `ask_counter_fee` are present only if the authenticated user is the owner of the ask order.

## OrderClosed

```javascript
event: OrderClosed
data: {
data:   "base": <integer>,
data:   "counter": <integer>,
data:   "id": <integer>,
data:   "tonce": <integer>,
data:   "quantity": <integer>,
data:   "price": <integer>
data: }
```

* **`base`:** *(integer)* The numeric identifier of the base asset of the order.
* **`counter`:** *(integer)* The numeric identifier of the counter asset of the order.
* **`id`:** *(integer)* The numeric identifier of the order.
* **`tonce`:** *(integer or `null`, conditional)* The tonce given in the `PlaceOrder` command that opened the order, or `null` if that command did not specify a tonce. Present only if the authenticated user is the owner of the order.
* **`quantity`:** *(integer)* The [scaled] amount of the base asset remaining to be traded at the time the order was closed. It is negative for a sell order and positive for a buy order.
* **`price`:** *(integer)* The [scaled] price at which the order had offered to trade.

## TickerChanged

```javascript
event: TickerChanged
data: {
data:   "base": <integer>,
data:   "counter": <integer>,
data:   "last": <integer>,
data:   "bid": <integer>,
data:   "ask": <integer>,
data:   "low": <integer>,
data:   "high": <integer>,
data:   "volume": <integer>
data: }
```

* **`base`:** *(integer)* The numeric identifier of the base asset of the book whose ticker changed.
* **`counter`:** *(integer)* The numeric identifier of the counter asset of the book whose ticker changed.
* **`last`:** *(integer or `null`)* The [scaled] price at which the last trade executed on the book, or `null` if no trade has executed on the book.
* **`bid`:** *(integer or `null`)* The [scaled] price of the highest-priced bid order on the book, or `null` if the book contains no bid orders.
* **`ask`:** *(integer or `null`)* The [scaled] price of the lowest-priced ask order on the book, or `null` if the book contains no ask orders.
* **`low`:** *(integer or `null`)* The [scaled] price at which the lowest-priced trade on the book executed within the preceding 24 hours, or `null` if no trade has executed on the book in the preceding 24 hours.
* **`high`:** *(integer or `null`)* The [scaled] price at which the highest-priced trade on the book executed within the preceding 24 hours, or `null` if no trade has executed on the book in the preceding 24 hours.
* **`volume`:** *(integer)* The [scaled] total amount of the base asset that has been traded on the book within the preceding 24 hours.





## UserTradeVolumeChanged

**[[ Version 2:**

```javascript
event: UserTradeVolumeChanged
data: {
data:   "asset": <integer>,
data:   "volume": <integer>
data: }
```

* **`asset`:** *(integer)* The numeric identifier of the asset whose trailing 30-day user trade volume has changed.
* **`volume`:** *(integer)* The [scaled] amount of the user's trailing 30-day trade volume in the specified asset.

**]]**


[HTTP Basic Authentication]: https://tools.ietf.org/html/rfc7617
    (The 'Basic' HTTP Authentication Scheme)
[Server-Sent Events]: https://www.w3.org/TR/eventsource/
[WebSocket API]: #WEBSOCKET-README.md
[scaled]: #scaling.md


# Futures API Specification

DEMO/STAGE site

**API endpoint URL: `https://stgwebapi.coinflex.com/`**

LIVE site

**API endpoint URL: `https://webapi.coinflex.com/`**

[scaled]: SCALE.md

## Contents

Currently, the Futures API supports the following endpoints:

* `/borrower/events`           	&#09; ([GET](#get-borrower-events))
* `/borrower/conversion/`     	&#09; ([GET](#get-borrower-conversion) | [POST](#post-borrower-conversion))
* `/borrower/converted_totals/`	&#09; ([GET](#get-borrower-converted_totals))
* `/borrower/collateral/`     	&#09; ([GET](#get-borrower-collateral))
* `/borrower/collateral/<id>` 	&#09; ([GET](#get-borrower-collateral-lt-id-gt))
* `/borrower/offers/`         	&#09; ([GET](#get-borrower-offers))
* `/borrower/offers/<id>`     	&#09; ([GET](#get-borrower-offers-lt-id-gt))
* `/borrower/loans/`          	&#09; ([GET](#get-borrower-loans) | [POST](#post-borrower-loans))
* `/borrower/loans/<id>`      	&#09; ([GET](#get-borrower-loans-lt-id-gt) | [POST](#post-borrower-loans-lt-id-gt) | [DELETE](#delete-borrower-loans-lt-id-gt))
* `/borrower/margin_ratios/`  	&#09; ([GET](#get-borrower-margin_ratios))


## Authentication

All method calls require [HTTP Basic authentication][]. The username portion of the Basic credentials is constructed by concatenating the numeric user ID, a slash, and the user's API authentication cookie. The password portion is simply the user's login passphrase.

[HTTP Basic authentication]: https://tools.ietf.org/html/rfc2617#section-2


## Common Record Types

### `<collateral>`

```json
{
    "asset_id": <integer>,
    "available": <integer>
    "total": <integer>
}
```

* **`asset_id`:** *(integer)* The numeric asset code of an asset in which the user's available collateral is reported.
* **`available`:** *(integer)* The [scaled][] amount of the user's available collateral in the identified asset.
* **`total`:** *(integer)* The [scaled][] amount of the user's equivalent account values in each asset that would remain if all of the user's outstanding loans were to be repaid (i.e. the users underlying collateral value measured in each asset).  The conceptual difference between this “total” figure and the “available” is that available collateral excludes funds needed for maintaining margin requirements, whereas total collateral represents a hypothetical scenario in which all loans are repaid and thus incurs no margin requirements.

### `<offer>`

```json
{
    "id": <integer>,
    "created": <integer>,
    "rescinded": <integer>,
    "asset_id": <integer>,
    "amount": <integer>,
    "min_amount": <integer>,
    "max_amount": <integer>,
    "term": <integer>,
    "initial_margin": <integer>,
    "maintenance_margin": <integer>,
    "apr": <integer>,
    "qualifiers": ["<string>", …]
}
```

* **`id`:** *(integer)* The numeric identifier of a loan offer.
* **`created`:** *(integer)* The micro-timestamp at which this offer was created.
* **`rescinded`:** *(integer, conditional)* The micro-timestamp at which this offer was rescinded. Present only if this offer is rescinded.
* **`asset_id`:** *(integer)* The numeric asset code of the asset in which a loan is offered.
* **`amount`:** *(integer)* The [scaled][] amount of the identified asset that is available for borrowing against this offer.
* **`min_amount`:** *(integer, conditional)* The [scaled][] minimum amount that may be borrowed against this offer in any one loan. If absent, there is no minimum.
* **`max_amount`:** *(integer, conditional)* The [scaled][] maximum amount that may be borrowed across all of the user's loans against this offer. If absent, there is no maximum.
* **`term`:** *(integer)* The maximum term of the offered loan, in seconds.
* **`initial_margin`:** *(integer)* The initial margin ratio of the offered loan, expressed with an implicit scale factor of 10000. This fraction of the loan amount is the minimum available collateral needed to initiate a loan against this offer.
* **`maintenance_margin`:** *(integer)* The maintenance margin ratio of the offered loan, expressed with an implicit scale factor of 10000. Must not exceed `initial_margin`.
* **`apr`:** *(integer)* The annualized interest rate of the offered loan, expressed with an implicit scale factor of 10000. For offers of futures contracts, this is always zero.
* **`qualifiers`:** *(array of strings, conditional)* The qualifiers that apply to this offer, if any.
	* **`promo`:** This is a promotional offer.
	* **`facility`:** This offer represents a loan facility that has been granted to the user.
	* **`corporate`:** This offer is available to corporate customers only.

### `<loan>`

```json
{
    "id": <integer>,
    "offer_id": <integer>,
    "initiated": <integer>,
    "asset_id": <integer>,
    "principal": <float>,
    "term": <integer>,
    "initial_margin": <integer>,
    "maintenance_margin": <integer>,
    "apr": <integer>,
    "qualifiers": ["<string>", …]
}
```

* **`id`:** *(integer)* The numeric identifier of an outstanding loan.
* **`offer_id`:** *(integer)* The numeric identifier of the offer against which this loan was initiated.
* **`initiated`:** *(integer)* The micro-timestamp at which this loan was initiated.
* **`asset_id`:** *(integer)* The numeric asset code of the asset in which this loan is denominated.
* **`principal`:** *(float)* The [scaled][] amount of the identified asset borrowed as principal in this loan. The present accrued amount is calculated as `ceil(principal * exp(apr/1e4 * (now() - initiated) / (365.2425 * 24 * 60 * 60 * 1000000)))`.
* **`term`:** *(integer)* The maximum term of this loan, in seconds. Repayment of this loan is due at micro-timestamp `initiated + term * 1000000`.
* **`initial_margin`:** *(integer)* The initial margin ratio of this loan, expressed with an implicit scale factor of 10000.
* **`maintenance_margin`:** *(integer)* The maintenance margin ratio of this loan, expressed with an implicit scale factor of 10000.
* **`apr`:** *(integer)* The annualized interest rate of this loan, expressed with an implicit scale factor of 10000. For loans of futures contracts, this is always zero.
* **`qualifiers`:** *(array of strings, conditional)* The qualifiers that apply to this loan, if any.
	* **`promo`:** This loan was initiated against a promotional offer.
	* **`facility`:** This loan represents a draw-down from a loan facility that has been granted to the user.
	* **`corporate`:** This loan was initiated against an offer that was available to corporate customers only.


## GET `/borrower/events`



> **Request**

```javascript
GET '/borrower/events' HTTP/1.1
```

> **Response**

```yml
HTTP/1.1 200 OK
Content-Type: text/event-stream; charset=UTF-8

event: Collateral
data: [<collateral>, …]

event: Offers
data: [<offer>, …]

event: OfferOpened
data: <offer>

event: OfferUpdated
data: <offer>

event: OfferClosed
data: {"id": <integer>}

event: Loans
data: [<loan>, …]

event: LoanInitiated
data: <loan>

event: LoanUpdated
data: <loan>

event: LoanTerminated
data: {"id": <integer>}
```

Returns a stream of events pertaining to the user's borrowing activity.
The response body is an indefinitely long document in [`text/event-stream`][EventSource] format.

Optionally, the Base64-encoded [HTTP Basic authentication][] string may be passed to this resource in an `auth` query string parameter rather than in the standard `Authorization` request header. This option is provided as a workaround for a deficiency in some [EventSource][] client implementations.

[EventSource]: https://www.w3.org/TR/eventsource/


## GET `/borrower/conversion/`

> **Request**

```javascript
GET '/borrower/conversion/' HTTP/1.1
```

> **Response**

```yml
HTTP/1.1 200 OK
Content-Type: application/json; charset=US-ASCII
```

```json
[
    {
        "asset_from": <integer>,
        "asset_to": <integer>
    },
    …
]
```

Returns the list of asset pairs available for conversion.

* **`asset_from`:** *(integer)* The numeric code of the asset to convert from.
* **`asset_to`:** *(integer)* The numeric code of the asset to convert to.

## POST `/borrower/conversion/`

> **Request**

```javascript
POST '/borrower/conversion/' HTTP/1.1
```

```yml
Content-Type: application/x-www-form-urlencoded

asset_from=<integer>&asset_to=<integer>&amount=<integer>
```

Initiates a conversion of assets.

* **`asset_from`:** *(integer)* .
* **`asset_to`:** *(integer)* .
* **`amount`:** *(integer)* The [scaled][] amount of the asset to convert from.

> **Response**

```yml
HTTP/1.1 201 Created
Content-Type: application/json; charset=US-ASCII
```

```json
{
    "asset_from": <integer>,
    "asset_to": <integer>,
    "amount": <integer>
}
```

> The `Location` response header contains the numeric identifier of the newly initiated loan.

> **Errors**

> * If the asset code specified in **`asset_from`** or **`asset_to`** was not found:

```yml
HTTP/1.1 404 Not Found
Content-Length: 0

<explanation>
```

> * If the request is invalid (e.g. missing attributes, not enough balance) this method returns:

```yml
HTTP/1.1 400 Bad Request
Content-Type: text/plain; charset=US-ASCII

<explanation>
```


## GET `/borrower/converted_totals/`

> **Request**

```javascript
GET '/borrower/converted_totals/' HTTP/1.1
```

> **Response**

```yml
HTTP/1.1 200 OK
Content-Type: application/json; charset=US-ASCII
```

```json
[
    {
        "asset_from": <integer>,
        "asset_to": <integer>,
        "total": <integer>
    },
    …
]
```

Returns the list of total converted quantities for each valid asset pair.

* **`asset_from`:** *(integer)* The numeric code of the asset to convert from.
* **`asset_to`:** *(integer)* The numeric code of the asset to convert to.
* **`total`:** *(integer)* The total quantity of the asset which has been converted.


## GET `/borrower/collateral/`


> **Request**


```javascript
GET '/borrower/collateral/' HTTP/1.1
```

> **Response**

```yml
HTTP/1.1 200 OK
Content-Type: application/json; charset=US-ASCII
```

```json
[<collateral>, …]
```

Returns the collateral available to the user in various assets.


## GET `/borrower/collateral/<id>`


> **Request**

```javascript
GET '/borrower/collateral/<id>' HTTP/1.1
```

* **`id`:** *(integer)* The numeric asset code of the asset in which to report available collateral.

> **Response**

```yml
HTTP/1.1 200 OK
Content-Type: application/json; charset=US-ASCII
```

```json
<collateral>
```

> **Errors**

> * If the specified asset was not found, then this method returns:

```yml
HTTP/1.1 404 Not Found
Content-Length: 0
```

Returns the collateral available to the user in the specified asset.

## GET `/borrower/offers/`


> **Request**

```javascript
GET '/borrower/offers/' HTTP/1.1
```

> **Response**

```yml
HTTP/1.1 200 OK
Content-Type: application/json; charset=US-ASCII
```

```json
[<offer>, …]
```

Returns the loan offers available to the user.

## GET `/borrower/offers/<id>`

> **Request**

```javascript
GET '/borrower/offers/<id>' HTTP/1.1
```


> **Response**

```yml
HTTP/1.1 200 OK
Content-Type: application/json; charset=US-ASCII
```
	
```json
<offer>
```

> **Errors**

> * If the specified loan offer was not found, then this method returns:

```yml
HTTP/1.1 404 Not Found
Content-Length: 0
```

> * If the specified loan offer is not visible to the user, then this method returns:

```yml
HTTP/1.1 403 Forbidden
Content-Length: 0
```

* **`id`:** *(integer)* The numeric identifier of the loan offer to return.

Returns the specified loan offer.

## GET `/borrower/loans/`

> **Request**

```javascript
GET '/borrower/loans/' HTTP/1.1
```

> **Response**

```yml
HTTP/1.1 200 OK
Content-Type: application/json; charset=US-ASCII
```

```json
[<loan>, …]
```

Returns the borrower's outstanding loans.

## GET `/borrower/loans/<id>`

> **Request**

```javascript
GET '/borrower/loans/<id>' HTTP/1.1
```

> **Response**

```yml
HTTP/1.1 200 OK
Content-Type: application/json; charset=US-ASCII
```
	
```json
<loan>
```

> **Errors**

> * If the specified loan was not found, then this method returns:

```yml
HTTP/1.1 404 Not Found
Content-Length: 0
```

> * If the specified loan is not visible to the user, then this method returns:

```yml
HTTP/1.1 403 Forbidden
Content-Length: 0
```

* **`id`:** *(integer)* The numeric identifier of the loan to return.

Returns the borrower's specified outstanding loan.

## POST `/borrower/loans/`

> **Request**

```javascript
POST '/borrower/loans/' HTTP/1.1
```

```yml
Content-Type: application/x-www-form-urlencoded

offer_id=<integer>&amount=<integer>
```

> **Response**

```yml
HTTP/1.1 201 Created
Location: <id>
Content-Type: application/json; charset=US-ASCII
```
	
```json
<loan>
```

> The `Location` response header contains the numeric identifier of the newly initiated loan.

> **Errors**

> * If the specified loan offer was not found, then this method returns:

```yml
HTTP/1.1 404 Not Found
Content-Length: 0
```

> * If the requested loan was not allowed, then this method returns:

```yml
HTTP/1.1 403 Forbidden
Content-Type: text/plain; charset=US-ASCII
```
		
```json
<explanation>
```

* **`offer_id`:** *(integer)* The numeric identifier of an available loan offer.
* **`amount`:** *(integer)* The [scaled][] amount of the offered asset to borrow.

Initiates a loan.

## POST `/borrower/loans/<id>`

> **Request**

```javascript
POST '/borrower/loans/<id>' HTTP/1.1
```

```yml
Content-Type: application/x-www-form-urlencoded

amount=<integer>
```

> **Response**

```yml
HTTP/1.1 204 No Content
```

> **Errors**

> * If the specified loan was not found, then this method returns:

```yml
HTTP/1.1 404 Not Found
Content-Length: 0
```

> * If the requested repayment was not allowed, then this method returns:

```yml
HTTP/1.1 403 Forbidden
Content-Type: text/plain; charset=US-ASCII
```

```json
<explanation>
```

* **`id`:** *(integer)* The numeric identifier of the outstanding loan to repay.
* **`amount`:** *(integer)* The [scaled][] amount to repay.

Partially repays an outstanding loan.

## DELETE `/borrower/loans/<id>`

> **Request**

```javascript
DELETE '/borrower/loans/<id>' HTTP/1.1
```

> **Response**

```yml
HTTP/1.1 204 No Content
```

> **Errors**

> * If the specified loan was not found, then this method returns:

```yml
HTTP/1.1 404 Not Found
Content-Length: 0
```

> * If the requested repayment was not allowed, then this method returns:

```yml
HTTP/1.1 403 Forbidden
Content-Type: text/plain; charset=US-ASCII
```

```json
<explanation>
```

* **`id`:** *(integer)* The numeric identifier of the outstanding loan to repay.

Fully repays an outstanding loan.


## GET `/borrower/margin_ratios/`

> **Request**

```javascript
GET '/borrower/margin_ratios/' HTTP/1.1
```

> **Response**

```yml
HTTP/1.1 200 OK
Content-Type: application/json; charset=US-ASCII
```

```json
{
    "asset_id": <integer>,
    "collateral": <integer>,
    "loan": <integer>,
    "ratio": <float>
}
```

* **`asset_id`:** *(integer)* The numeric asset code of an asset in which the user's margin ratio is reported.
* **`collateral`:** *(integer)* The scaled amount of the user's available collateral in the asset.
* **`loan`:** *(integer)* The scaled amount of the asset borrowed.
* **`ratio`:** *(float)* The margin ratio of the asset.

Returns the margin ratio of the user for all assets where leverage funding has been taken out.  However it is recommended that users should connect to the Event Stream resource at [/borrower/events](#get-borrower-events) and perform the necessary calculations on the data provided therein.


# CoinFLEX API Client Implementation Guide

This document supplements the [CoinFLEX WebSocket API reference](#WEBSOCKET-README.md) to provide non-normative recommendations to implementers of CoinFLEX API client software. This document assumes no particular programming language, model, or library and simply discusses the message flow between the client and the server at a network protocol level.

## Authenticating

Client authentication to the CoinFLEX API is in the form of an elliptic-curve digital signature, where the private key is derived from the user's numeric ID and textual passphrase and the message that is signed encompasses the numeric user ID and two nonces, one generated by the server and the other generated by the client. Although the mathematics involved comprise only simple arithmetic, they are rather cumbersome, and so a library implementation is suggested. The [CoinFLEX JavaScript client library](https://github.com/coinflex-exchange/js-library) supplies a pure-JavaScript implementation of the necessary algorithms, and the [CoinFLEX Java client library](https://github.com/coinflex-exchange/java-library) makes use of the standard Java Cryptography Architecture or the [Bouncy Castle library](http://bouncycastle.org/java.html), depending on the Java release.

Details of the signature generation procedure are provided in the [CoinFLEX Authentication Process](AUTH.md) document. To summarise, the signature algorithm to use is "SHA-224 with ECDSA," and the elliptic curve to use is **secp224k1**.

>  This structure is defined in Appendix C of [SEC 1: Elliptic Curve Cryptography](http://www.secg.org/sec1-v2.pdf) and is reproduced here for convenience:

```cpp
ECDSA-Sig-Value ::= SEQUENCE {
        r INTEGER,
        s INTEGER,
        a INTEGER OPTIONAL,
        y CHOICE { b BOOLEAN, f FieldElement } OPTIONAL
}
```

One challenge that often arises when using external cryptography libraries to generate the digital signature is that the two numeric components of the signature may not be directly exposed by the library's API. Instead, often the library will return a DER-encoded structure containing the signature components.



In practice, libraries omit the optional fields `a` and `y` and encode only the `r` and `s` integers. These integers are what must be transmitted to CoinFLEX in the `signature` field of the `Authenticate` command message. An algorithm for extracting these integer values from the DER-encoded `ECDSA-Sig-Value` follows:

1. The value of the first byte of the DER encoding must be `0x30` (the ASN.1 tag for a `SEQUENCE`), and the value of the second byte must be equal to the number of bytes remaining in the encoding after these first two bytes.
1. The value of the third byte must be `0x02` (the ASN.1 tag for an `INTEGER`), and the value of the fourth byte gives the length (in bytes) of the encoding of the first integer, `r`. Capture this number of bytes (following the length byte) as *r*, the first component of the signature.
1. The value of the next byte (after the bytes captured as *r*) must be `0x02`, and the value of the following byte gives the length (in bytes) of the encoding of the second integer, `s`. Capture this number of bytes (following the length byte) as *s*, the second component of the signature.
1. The bytes captured as *s* must extend to the end of the overall encoding, assuming the optional `a` and `y` fields are omitted.
1. The `Authenticate` command expects each of the two signature components, *r* and *s*, to be 28 bytes in length. The DER encoding of each of these components may have spanned fewer than 28 bytes, in which case you must zero-extend (with `0x00` bytes) the encoding on the left to exactly 28 bytes, or the encoding may have been 29 bytes in length, in which case you must truncate the encoding on the left to exactly 28 bytes, and the value of the removed byte must have been `0x00`.
1. With *r* and *s* now exactly 28 bytes in length, encode these byte strings using Base64 and place the encoded character strings into an array of two elements. This array becomes the value of the `signature` field in the `Authenticate` message.

## Maintaining a Local View of an Order Book

Implementers may wish to maintain a local view of an order book. This can be effected by capturing a snapshot of the live order book and then incrementally applying incoming notices to keep the view current. Maintaining such a view incrementally is vastly more efficient than repeatedly polling the server for the complete order book, and your view is guaranteed to remain perfectly consistent with the live order book on the server if you exactly implement these rules:

* Start by atomically capturing a snapshot of the live order book and subscribing to incremental updates to that book by sending a `WatchOrders` command with `watch` set to **true**.
        * It is possible that you may begin to receive order update notices before you receive the command reply containing the initial snapshot of the live order book. If this occurs, then you must temporarily store these early notices and apply them to the snapshot once you receive it.
        * When you receive the reply to your `WatchOrders` command, build your initial view of the order book from the array given in the `orders` field of the reply message, noting that bids are represented with positive quantities and asks with negative quantities. Then apply to this initial view any early update notices that you may have received by following the rules for applying update notices, given below.
        * Note that the snapshot sent by the server contains at most the top 1000 bids and the top 1000 asks from the live order book at the time when the snapshot was taken.
* When you receive an `OrderOpened` notice, add the described order to your view, which will not have contained any order with the given ID prior to the addition.
* When you receive an `OrderModified` notice, modify the described order in your view. Note that the quantity and/or the price of the described order could have been updated. The described order cannot cross the bid/ask.
* When you receive an `OrderClosed` notice, delete the identified order from your view.
        * If your view did not contain the identified order, then simply ignore the notice, as it pertains to an order that was open at the time of your initial snapshot of the live order book but was not among the top 1000 bids and top 1000 asks at that time.
* When you receive an `OrdersMatched` notice:
        * If the notice contains a `bid` field, then find in your view the order whose ID is specified in the `bid` field of the notice, and set that order's remaining quantity to the quantity given in the `bid_rem` field of the notice.
        * If the notice contains an `ask` field, then find in your view the order whose ID is specified in the `ask` field of the notice, and set that order's remaining quantity to the quantity given in the `ask_rem` field of the notice. Note that the quantity given in the `ask_rem` field is always positive, so you would need to store the negative of this value if you are using the sign of the order quantity to indicate the side of the book in your view.
        * If your view did not contain an order identified by the `bid` or `ask` field of the notice, then you can ignore that side of the trade, as it pertains to an order that was open at the time of your initial snapshot of the live order book but was not among the top 1000 bids and top 1000 asks at that time.

## Tracking Fills of Your Orders

When you place an order, you will likely want to know when it fills, at what price, and by what quantity. The `OrdersMatched` notice provides all of this information, but there is a caveat that you must account for. You may receive one or more `OrdersMatched` notices pertaining to your order _before_ you have received the reply to your `PlaceOrder` command. Because you won't learn the ID of your new order until you receive the reply message, you may not recognise the notices as pertaining to your order. What follows are two strategies for dealing with this.

* If you specify a tonce when you place your order, then you can recognise any notices pertaining to your new order, even before you learn its ID, because the notices will bear the same tonce. Your tonce will appear in the `tonce` field of `OrderOpened` and `OrderClosed` notices and in the `bid_tonce` or `ask_tonce` field of `OrdersMatched` notices.
* Alternatively, between the time when you transmit your `PlaceOrder` command and the time when you receive the reply to that command, you can temporarily store any notices pertaining to orders that belong to you but whose IDs you do not recognise. You must then process those notices after receiving the reply that contains the ID of your new order.
        * If you are watching all orders on a book, then you can distinguish notices pertaining to your own orders because they will contain a `tonce` (or `bid_tonce` or `ask_tonce`) field (whose value will be `null` if you did not specify a tonce in your `PlaceOrder` command). These fields will be absent from notices pertaining to orders that belong to other users.

Note that it is possible to place an order that matches against one of your own open orders. In this case the emitted `OrdersMatched` notice will contain both `bid_tonce` and `ask_tonce` fields, indicating that both orders belonged to you. Such "self-trades" are never assessed any trade fees, and they do not contribute to trade volumes.

## How Balance Reservations Work

When you place an order, some quantity of your available balance becomes reserved. A bid order takes its reservation from your counter asset balance, while an ask order takes its reservation from your base asset balance. The reserved amount is the amount that you would trade away if your order were to be matched. Cancelling your order causes its reservation to be returned to your available balance.

The amount of an ask order's reservation is simply the quantity of the base asset that the order is seeking to sell. The amount of a bid order's reservation is calculated by the formula `ceil(quantity * price / 10000)`, where `quantity` and `price` are the [scaled](#scaling) values given in the `PlaceOrder` command, and the result of the formula has the scale of the counter asset. As an example, an order to buy 12345 units of the base asset at a price of 1234500 would reserve 1523991 units of the counter asset.

## Stochastic Rounding

When the trade engine computes a trade total (the amount of the counter asset that changes hands in a trade) or a trading fee, it must round the exact number to a whole number of asset [units](#scaling). Rather than following a deterministic rounding rule — such as "round to the nearest integer" or "always round up" — which could be gamed by savvy users to the detriment of others, the trade engine performs *stochastic rounding*: real numbers very close to the next lower integer are very likely to be rounded down, and real numbers very close to the next higher integer are very likely to be rounded up. The exact probability of rounding up is precisely equal to the fractional part of the real number. For example, 43.21 has a 21% chance of being rounded up to 44 (and a 79% chance of being rounded down to 43). Stochastic rounding minimizes the cumulative rounding error in the long run, resulting in fairer trades and fairer fees for all users.

## How Fees Affect Trade Quantities

At the time of this writing, CoinFLEX charges trading fees only on the counter asset in a trade. On the seller's side the trading fee is taken from the proceeds of the sale, meaning the seller receives slightly less of the counter asset from the sale than the amount of the counter asset that was traded. The situation on the buyer's side is less clear: the buyer receives an amount of the base asset in the trade but must pay the trading fee in the counter asset and may have insufficient available balance in the counter asset to pay the fee. In this scenario, the buyer's trading fee is taken out of the bid order's reservation, leaving a lesser amount of the reservation remaining to be traded. As an example, an order to buy Ƀ1.0000 might end up buying only Ƀ0.9997 because the reserved funds that would have gone to buy the other Ƀ0.0003 were consumed by the trading fee instead. In the usual case, the buyer has sufficient available balance in the counter asset to pay the fee, so no reserved funds are consumed by the fee.

In a partial fill scenario, the quantity remaining in the bid order after the trade may be slightly less than the bid order quantity before the trade minus the traded quantity. This happens whenever the bid order's remaining balance reservation in the counter asset is not sufficient to purchase the remaining quantity of the base asset. In this case, a small amount of the counter asset may be returned from the balance reservation into the buyer's available balance.

## Maintaining a Local View of Your Balances

Implementers may wish to maintain a local view of their account balances at all times. Because `BalanceChanged` notices may be delivered asynchronously at any time, an implementation may be challenged to correlate incoming `BalanceChanged` notices with other events in the system. The following rules may be helpful:

* For each asset in which you have a balance, you will need to keep track of the balance that you most recently observed in a `BalanceChanged` notice and a collection of balance deltas that you anticipate observing in upcoming `BalanceChanged` notices.
* When you receive a `BalanceChanged` notice, compute its balance _delta_ as the new balance it reports minus the balance you had most recently observed in the same asset. Remove this delta, if it is present, from the collection of balance deltas that you anticipate observing.
* When you transmit a `PlaceOrder` command, compute the amount of the reservation that it will require, as described in the section above, and add the negative of this amount to the collection of balance deltas that you anticipate observing.
        * If you later receive an error reply to your `PlaceOrder` command, be certain to remove the delta from the collection.
* When you receive an `OrderClosed` notice pertaining to your own order, compute the amount of the reservation that it had been requiring, as described in the section above, and add this amount, if it is non-zero, to the collection of balance deltas that you anticipate observing.
* When you receive an `OrdersMatched` notice pertaining to your own order:
        * If your order was a bid, then add the traded quantity to the collection of base-asset balance deltas that you anticipate observing. Compute the return of excess reservation, if any, as described in the section above, and add this amount, if it is non-zero, to the collection of counter-asset balance deltas that you anticipate observing.
        * If your order was an ask, then add the traded total minus the trading fee to the collection of counter-asset balance deltas that you anticipate observing.
* At any instant between notices, you can assume your usable available balance in any given asset is equal to the balance reported in the most recently delivered `BalanceChanged` notice pertaining to that asset, plus the sum of the deltas in the collection of balance deltas that you anticipate observing in that asset.
* No balance delta should remain in any collection of anticipated balance deltas for very long. If you see that a balance delta appears to be "stuck" in a collection of anticipated balance deltas, then this means that you have a logic bug.

The above rules imply the following general truths about the delivery order of notices:

* An `OrdersMatched` notice always precedes the `BalanceChanged` notices that result from the trade.
* An `OrderClosed` notice always precedes any `BalanceChanged` notice that results from closing the order.
* `BalanceChanged` notices are always delivered strictly in the order in which the balance changes occurred in the trade engine.

An additional truth that is not implied by the above rules, but is nonetheless true, is that an `OrderOpened` notice always _follows_ the `BalanceChanged` notice that resulted from taking out the reservation that was required to open the order.


# Request Limits

CoinFLEX's application programming interface (API) allows our clients to access and control their accounts or view our market data using custom-written software. To protect the performance of the system, we impose certain limits:

| Metric                  |                            Limit |
|:------------------------|---------------------------------:|
| Open orders             |                   1,000 per user |
| Authentication attempts |          1,000 per hour per user |
| Order placements*       |          200 per second per user |
| Information requests†   |    10 per 10 seconds per session |
| Records requests‡       |         30 per 1 minute per user |
| Conversion requests     |         1 per 5 seconds per user |

\* "Order placements" also include order cancellations and market order estimates. This is for websockets. Via REST, the limit is 300 per 10 second window.

† "Information requests" include balance inquiries, open order listings, and trade volume inquiries.

‡ "Records requests" pertain to requests for historical records, such as past trades.


END----------------------------------------


# Reference:

[OKEX Reference](https://www.okex.com/docs/en/#futures-README).

[Huobi Reference](https://huobiapi.github.io/docs/dm/v1/en/).

[CoinFLEX Reference](https://github.com/coinflex-exchange/API).

[Binance Reference](https://binanceapitest.github.io/Binance-Futures-API-doc/wss/#individual-symbol-ticker-streams).


# Table:

 | v2 Requirement | OKEx (Huobi) functions | CoinFLEX Equivalent Function
-------- | --------- | ------- | -----------
General | | |
Authentication | Standard | Standard | EDCSA
Accounts | Linear, Inverse |  Funding, Spot, Margin, Perp, Options, Fiat, Savings,| Spot, June, September
Server | It is recommended to access CoinFLEX APIs from AWS Japan for better performance | It is recommended to access Huobi API from AWS Japan for better stability. If your server is in China mainland, it may be not stable. | AWS Europe
Rest API | Plan to have Rest  capabilities closer to the other exchanges (10/s) | It is strongly recommended to use Ali-cloud server in Hong Kong.  We strongly recommend you to use REST APIs in performing trading activities and making withdrawals. | It is weak for people to use Rest API. Our Rest API is based off the Websocket API and is inferior
Websocket API | | It is suggested to use Websocket API to get data update, lime market data and order update | Websocket are for real traders
Rest - COINFLEX Tickers | | | https://webapi.coinflex.com/
GET /balances/ | Gets the user's available and reserved balances in all assets. This gets balances for all spot assets. | N/A | https://github.com/coinflex-exchange/API/blob/master/REST.md#get-assets 


# API:

## Gets a complete list of  CoinFLEX SPOT and Futures markets

in v2:

* Change base:counter to ticker
* have "type"
* Include a lot more information about the contract compared to before
* For Perps, maturity is the following day

> Example of a successful get markets request:

```json
[
    {
        "market_id": "BTC-USD",
        "name": "BTC/USD Spot"
        "base": "BTC",
        "counter": "USD",
        "type": "spot"
        "tick_size": "0.1"
        "trade_increment": "0.001"
    },
    {
        "market_id": "BTC-USD-SWAP-LIN",
        "name": "BTC/USD Perpetual (Linear)"
        "base": "BTC",
        "counter": "USD",
        "type": "future"
        "tick_size": "0.5"
        "trade_increment": "0.001"
        "delivery": "2020-05-07"
        "settlement_currency": "USD"
        "contract_val_currency": "BTC"        
    },
    {
        "market_id": "BTC-USD-REPO-INV",
        "name": "BTC/USD Repo (Inverse)"
        "base": "BTC-USD",
        "counter": "BTC-USD-SWAP-INV",
        "type": "repo"
        "tick_size": "0.00005"
        "trade_increment": "1"
        "settlement_currency": "BTC"
        "contract_val_currency": "USD"
    },
    {
        "market_id": "BTC-USD-SPR-PQ-LIN",
        "name": "BTC/USD Perp-Qtr Spread (Linear)"
        "base": "BTC-USD-SWAP-LIN",
        "counter": "BTC-USD-200626-LIN",
        "type": "spread"
        "tick_size": "1"
        "trade_increment": "0.001"
        "settlement_currency": "USD"
        "contract_val_currency": "BTC"        
    }]
```

### HTTP Request

`GET /markets/`

* id: Unique identified of the trading market

* name: English name of the market

* base: transaction currency (BTC in BTC/USD)

* counter: base currency (USD in BTC/USD)




# Authentication:

> To authorize, use this code:


```javascript
const kittn = require('kittn');

let api = kittn.authorize('meowmeowmeow');
```

> Make sure to replace `meowmeowmeow` with your API key.

Kittn uses API keys to allow access to the API. You can register a new Kittn API key at our [developer portal](http://example.com/developers).

Kittn expects for the API key to be included in all API requests to the server in a header that looks like the following:

`Authorization: meowmeowmeow`

<aside class="notice">
You must replace <code>meowmeowmeow</code> with your personal API key.
</aside>

# Kittens

## Get All Kittens

```ruby
require 'kittn'

api = Kittn::APIClient.authorize!('meowmeowmeow')
api.kittens.get
```

```python
import kittn

api = kittn.authorize('meowmeowmeow')
api.kittens.get()
```

```shell
curl "http://example.com/api/kittens"
  -H "Authorization: meowmeowmeow"
```

```javascript
const kittn = require('kittn');

let api = kittn.authorize('meowmeowmeow');
let kittens = api.kittens.get();
```

> The above command returns JSON structured like this:

```json
[
  {
    "id": 1,
    "name": "Fluffums",
    "breed": "calico",
    "fluffiness": 6,
    "cuteness": 7
  },
  {
    "id": 2,
    "name": "Max",
    "breed": "unknown",
    "fluffiness": 5,
    "cuteness": 10
  }
]
```

This endpoint retrieves all kittens.

### HTTP Request

`GET http://example.com/api/kittens`

### Query Parameters

Parameter | Default | Description
--------- | ------- | -----------
include_cats | false | If set to true, the result will also include cats.
available | true | If set to false, the result will include kittens that have already been adopted.

<aside class="success">
Remember — a happy kitten is an authenticated kitten!
</aside>

## Get a Specific Kitten

```ruby
require 'kittn'

api = Kittn::APIClient.authorize!('meowmeowmeow')
api.kittens.get(2)
```

```python
import kittn

api = kittn.authorize('meowmeowmeow')
api.kittens.get(2)
```

```shell
curl "http://example.com/api/kittens/2"
  -H "Authorization: meowmeowmeow"
```

```javascript
const kittn = require('kittn');

let api = kittn.authorize('meowmeowmeow');
let max = api.kittens.get(2);
```

> The above command returns JSON structured like this:

```json
{
  "id": 2,
  "name": "Max",
  "breed": "unknown",
  "fluffiness": 5,
  "cuteness": 10
}
```

This endpoint retrieves a specific kitten.

<aside class="warning">Inside HTML code blocks like this one, you can't use Markdown, so use <code>&lt;code&gt;</code> blocks to denote code.</aside>

### HTTP Request

`GET http://example.com/kittens/<ID>`

### URL Parameters

Parameter | Description
--------- | -----------
ID | The ID of the kitten to retrieve

## Delete a Specific Kitten

```ruby
require 'kittn'

api = Kittn::APIClient.authorize!('meowmeowmeow')
api.kittens.delete(2)
```

```python
import kittn

api = kittn.authorize('meowmeowmeow')
api.kittens.delete(2)
```

```shell
curl "http://example.com/api/kittens/2"
  -X DELETE
  -H "Authorization: meowmeowmeow"
```

```javascript
const kittn = require('kittn');

let api = kittn.authorize('meowmeowmeow');
let max = api.kittens.delete(2);
```

> The above command returns JSON structured like this:

```json
{
  "id": 2,
  "deleted" : ":("
}
```

This endpoint deletes a specific kitten.

### HTTP Request

`DELETE http://example.com/kittens/<ID>`

### URL Parameters

Parameter | Description
--------- | -----------
ID | The ID of the kitten to delete

